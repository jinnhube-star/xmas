<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical AI Christmas Tree</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.0/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: radial-gradient(circle, #001 0%, #000 100%); overflow: hidden; font-family: 'Playfair Display', serif; }
        #ui { position: absolute; top: 30px; left: 30px; color: gold; z-index: 10; pointer-events: none; }
        #controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 10; display: flex; gap: 10px; }
        .glass-btn { background: rgba(255, 215, 0, 0.1); border: 1px solid gold; color: gold; padding: 12px 20px; border-radius: 5px; cursor: pointer; pointer-events: all; backdrop-filter: blur(5px); }
        #v-preview { position: absolute; top: 10px; right: 10px; width: 150px; border: 1px solid gold; border-radius: 10px; }
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<div id="ui">
    <h1>âœ¨ The Eternal Glitter Tree</h1>
    <p id="status">Loading AI Magic...</p>
</div>

<video id="v-preview" autoplay playsinline></video>

<div id="controls">
    <label class="glass-btn" for="photo-in">ðŸ“¸ Add Memory</label>
    <input type="file" id="photo-in" multiple accept="image/*">
    <label class="glass-btn" for="music-in">ðŸŽµ Add Music</label>
    <input type="file" id="music-in" accept="audio/*">
</div>

<audio id="player" loop></audio>

<script>
/** 1. UPGRADED TREE GEOMETRY (Tiered & Glittery) **/
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const pCount = 8000;
const treeGeometry = new THREE.BufferGeometry();
const treePositions = new Float32Array(pCount * 3);
const treeColors = new Float32Array(pCount * 3);
const originalPos = new Float32Array(pCount * 3);

for (let i = 0; i < pCount; i++) {
    // Tiered logic for branches
    const tier = Math.floor(Math.random() * 5);
    const tierHeight = (tier / 5) * 10 - 5;
    const tierRadius = (1.1 - (tier / 5)) * 4.5;
    
    const angle = Math.random() * Math.PI * 2;
    const r = Math.random() * tierRadius;
    
    const x = Math.cos(angle) * r;
    const y = tierHeight + (Math.random() * 2);
    const z = Math.sin(angle) * r;

    treePositions[i*3] = originalPos[i*3] = x;
    treePositions[i*3+1] = originalPos[i*3+1] = y;
    treePositions[i*3+2] = originalPos[i*3+2] = z;

    // Color: Mostly Greens + Gold/Red "Ornaments"
    if (Math.random() > 0.95) {
        treeColors[i*3] = 1; treeColors[i*3+1] = 0.8; treeColors[i*3+2] = 0; // Gold
    } else if (Math.random() > 0.98) {
        treeColors[i*3] = 1; treeColors[i*3+1] = 0.2; treeColors[i*3+2] = 0.2; // Red
    } else {
        treeColors[i*3] = 0; treeColors[i*3+1] = Math.random() * 0.5 + 0.2; treeColors[i*3+2] = 0.1; // Green
    }
}

treeGeometry.setAttribute('position', new THREE.BufferAttribute(treePositions, 3));
treeGeometry.setAttribute('color', new THREE.BufferAttribute(treeColors, 3));

const treeMaterial = new THREE.PointsMaterial({ 
    size: 0.04, 
    vertexColors: true, 
    transparent: true, 
    opacity: 0.8,
    blending: THREE.AdditiveBlending 
});
const tree = new THREE.Points(treeGeometry, treeMaterial);
scene.add(tree);

// Add Top Star
const starGeo = new THREE.OctahedronGeometry(0.5, 0);
const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
const star = new THREE.Mesh(starGeo, starMat);
star.position.y = 6.5;
scene.add(star);

camera.position.z = 15;

/** 2. PHOTO HANDLING & "STORAGE" (Local First) **/
const frameGroup = new THREE.Group();
scene.add(frameGroup);
const photoStack = [];

document.getElementById('photo-in').onchange = (e) => {
    Array.from(e.target.files).forEach(file => {
        const url = URL.createObjectURL(file);
        createFrame(url);
        // [WISH: Upload to Supabase here for persistence]
    });
};

function createFrame(url) {
    const tex = new THREE.TextureLoader().load(url);
    const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(2.5, 2.5),
        new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide })
    );
    // Position in orbit
    const angle = Math.random() * Math.PI * 2;
    mesh.position.set(Math.cos(angle)*8, (Math.random()-0.5)*10, Math.sin(angle)*8);
    mesh.lookAt(0,0,0);
    frameGroup.add(mesh);
    photoStack.push(mesh);
}

/** 3. GESTURE RECOGNITION **/
let isExploded = false;
let lastX = 0;

function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        document.getElementById('status').innerText = "Magic Active âœ¨";
        const h = results.multiHandLandmarks[0];
        
        // Fist/Open Logic (Explode/Recreate)
        const d = Math.hypot(h[8].x - h[0].x, h[8].y - h[0].y);
        if (d < 0.3 && isExploded) toggleTree(false);
        else if (d > 0.6 && !isExploded) toggleTree(true);

        // Wave Logic (Orbit)
        const currentX = h[0].x;
        if (Math.abs(currentX - lastX) > 0.02) {
            gsap.to(frameGroup.rotation, { y: frameGroup.rotation.y + (currentX - lastX) * 10, duration: 0.5 });
        }
        lastX = currentX;

        // Pinch Logic (Focus)
        const p = Math.hypot(h[8].x - h[4].x, h[8].y - h[4].y);
        if (p < 0.04) gsap.to(camera.position, { z: 7, duration: 1 });
        else gsap.to(camera.position, { z: 15, duration: 1 });
    }
}

function toggleTree(explode) {
    isExploded = explode;
    const pos = tree.geometry.attributes.position.array;
    for (let i = 0; i < pCount; i++) {
        gsap.to(pos, {
            [i*3]: explode ? (Math.random()-0.5)*40 : originalPos[i*3],
            [i*3+1]: explode ? (Math.random()-0.5)*40 : originalPos[i*3+1],
            [i*3+2]: explode ? (Math.random()-0.5)*40 : originalPos[i*3+2],
            duration: 2.5, ease: "elastic.out(1, 0.75)",
            onUpdate: () => tree.geometry.attributes.position.needsUpdate = true
        });
    }
}

const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({ maxNumHands: 1, modelComplexity: 1 });
hands.onResults(onResults);

new Camera(document.getElementById('v-preview'), {
    onFrame: async () => { await hands.send({image: document.getElementById('v-preview')}); },
    width: 640, height: 480
}).start();

function animate() {
    requestAnimationFrame(animate);
    tree.rotation.y += 0.005;
    star.rotation.y += 0.05;
    // Glitter Twinkle
    tree.material.opacity = 0.5 + Math.sin(Date.now() * 0.005) * 0.5;
    renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>